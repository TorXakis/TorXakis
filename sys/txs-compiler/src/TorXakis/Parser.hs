{-# LANGUAGE TemplateHaskell #-}
module TorXakis.Parser
    ( ParsedDefs
    , adts
    , funcs
    , consts
    , txsP
    , parseFile
    , parse
    )
where

import           Control.Arrow             (left)
import           Control.Monad.Identity    (runIdentity)
import qualified Data.Text                 as T
import           Lens.Micro                (Lens', to, (%~), (^.))
import           Lens.Micro.TH             (makeLenses)
import           Text.Parsec               (eof, many, runParserT, (<|>))

import           TorXakis.Compiler.Error   (Error)
import           TorXakis.Parser.Common    (TxsParser)
import           TorXakis.Parser.ConstDecl (constDeclsP)
import           TorXakis.Parser.Data
import           TorXakis.Parser.FuncDefs  (fdeclP)
import           TorXakis.Parser.TypeDefs  (adtP)

-- | TorXakis definitions generated by the parser.
data ParsedDefs = ParsedDefs
    { _adts   :: [ADTDecl]
    , _funcs  :: [FuncDecl]
    , _consts :: [FuncDecl]
    } deriving (Eq, Show)
makeLenses ''ParsedDefs

parse :: String -> Either Error ParsedDefs
parse = undefined

parseFile :: FilePath -> IO (Either Error ParsedDefs)
parseFile fp =  left (T.pack . show) <$> do
    input <- readFile fp
    return $ runIdentity (runParserT txsP (mkState 1000) fp input)


-- | TorXakis top-level definitions
data TLDef = TLADT ADTDecl
           | TLFunc FuncDecl -- TODO: make this a list of '[FuncDecl]', and rename to 'TLFuncs'
           | TLConsts [FuncDecl]

-- | Group a list of top-level definitions per-type.
asParsedDefs :: [TLDef] -> ParsedDefs
asParsedDefs = foldr sep empty
    where
      sep (TLADT a)     = adts %~ (a:)
      sep (TLFunc f)    = funcs %~ (f:)
      sep (TLConsts cs) = consts %~ (cs++)
      empty = ParsedDefs [] [] []

-- | Root parser for the TorXakis language.
txsP :: TxsParser ParsedDefs
txsP = do
    ts <- many $  fmap TLADT    adtP
              <|> fmap TLFunc   fdeclP
              <|> fmap TLConsts constDeclsP
    eof
    return $ asParsedDefs ts
