{-# LANGUAGE OverloadedStrings #-}
module TorXakis.Parser where

import           Text.ParserCombinators.Parsec.Language (haskell)
import           Data.Text (Text)
import qualified Data.Text as T
import           Text.Parsec.String (Parser)
import           Text.Parsec.Token (identifier, lexeme, symbol)
import           Text.Parsec.String (parseFromFile)
import           Text.Parsec (parseTest, (<|>), many, (<?>), label, eof)
import           Text.Parsec.Char (lower, upper, oneOf, alphaNum, string)
import           Data.List.NonEmpty (NonEmpty ((:|)))
import           Text.Parsec (unexpected, sepBy)
import           Control.Arrow (left)

import           TorXakis.Sort.FieldDefs (FieldDef (FieldDef), FieldDefs, fieldDefs, emptyFieldDefs)
import           TorXakis.Sort.Name (Name, fromNonEmpty)
import           TorXakis.Sort.ADTDefs (ADTDef (ADTDef), Sort, Unchecked, U (U))
import           TorXakis.Sort.ConstructorDefs ( ConstructorDef (ConstructorDef)
                                               , ConstructorDefs, constructorDefs)

import           TorXakis.Compiler.Error (Error)

parse :: String -> Either Error ParsedDefs
parse = undefined

parseFile :: FilePath -> IO (Either Error ParsedDefs)
parseFile fp =  left (T.pack . show) <$> parseFromFile txsP fp

-- | TorXakis definitions generated by the parser.
data ParsedDefs = ParsedDefs
    { adts  :: [UADTDef]
    , fdefs :: [UFuncDef]
    } deriving (Eq, Show)

txsP :: Parser ParsedDefs
txsP = do
    as <- many adtP
    eof
    return $ ParsedDefs as []

type UADTDef = ADTDef Unchecked

-- | Function definition.
data FuncDef sortRef = FuncDef
    deriving (Eq, Show)

type UFuncDef = FuncDef Unchecked

-- ** Sorts

sortP :: Parser Name
sortP = txsLexeme (ucIdentifier "Sorts")

txsLexeme :: Parser a -> Parser a
txsLexeme = lexeme haskell

txsSymbol :: String -> Parser String
txsSymbol = symbol haskell

-- ** Fields

fieldListP :: Parser [UFieldDef]
fieldListP =  do
    fns <- txsLexeme lcIdentifier `sepBy` txsSymbol ","
    _  <- txsSymbol "::"
    fs <- U . Right <$> sortP
    return $ mkFieldWithSort fs <$> fns
    where
      mkFieldWithSort fs fn = FieldDef fn fs md
          where md = ""


lcIdentifier :: Parser Name
lcIdentifier = fromNonEmpty <$> identifierNE idStart
    where
      idStart = lower <|> oneOf "_"
                `label`
                "Identifiers must start with a lowercase character or '_'"

ucIdentifier :: String -> Parser Name
ucIdentifier what  = fromNonEmpty <$> identifierNE idStart
    where
      idStart = upper
                `label`
                (what ++ " must start with an uppercase character")

identifierNE :: Parser Char -> Parser (NonEmpty Char)
identifierNE idStart = (:|) <$> idStart <*> idEnd
    where
      idEnd  = many $
          alphaNum <|> oneOf "_"
          `label`
          "Identifiers must contain only alpha-numeric characters or '_'"

fieldsP :: Parser (FieldDefs Unchecked)
fieldsP = nonEmptyFieldsP <|> emptyFieldsP
    where nonEmptyFieldsP = do
              txsSymbol "{"
              fdefs <- aListOf fieldListP ";" (fieldDefs . concat)
              txsSymbol "}"
              return fdefs
          emptyFieldsP = return emptyFieldDefs
    
type UFieldDef = FieldDef Unchecked

-- ** Constructors

cstrP :: Parser (ConstructorDef Unchecked)
cstrP = do
    cn <- txsLexeme (ucIdentifier "Constructors")
    fs <- fieldsP
    return $ ConstructorDef cn fs

cstrsP :: Parser (ConstructorDefs Unchecked)
cstrsP = aListOf cstrP "|" constructorDefs

-- | Parsing via smart constructors.
--
--
-- TODO: add some more details.
aListOf :: Show e
        => Parser a            -- ^ The parser for the items.
        -> String              -- ^ String used to separate the items.
        -> ([a] -> Either e b) -- ^ A smart constructor.
        -> Parser b
aListOf p sep f = do
    as <- p `sepBy` txsSymbol sep
    case f as of
        Left err -> unexpected $ show err
        Right val -> return val

-- ** ADT's

adtP :: Parser (ADTDef Unchecked)
adtP = do
    txsSymbol "TYPEDEF"
    an <- txsLexeme (ucIdentifier "ADT's")
    txsSymbol "::="
    cs <- cstrsP
    txsSymbol "ENDDEF"
    return $ ADTDef an cs
