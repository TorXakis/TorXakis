{-# LANGUAGE OverloadedStrings #-}
module TorXakis.Parser
    ( ParsedDefs
    , adts
    , txsP
    , parseFile
    )
where

import qualified Data.Text as T
import           Data.Text (Text)
import           Text.Parsec ( ParsecT, (<|>), many, label, eof, unexpected
                             , sepBy, getPosition, sourceLine, sourceColumn
                             , runParserT
                             )
import           Text.ParserCombinators.Parsec.Language (haskell)                 
import           Text.Parsec.Token ( lexeme, symbol
                                   , GenLanguageDef (LanguageDef), commentStart, commentEnd
                                   , commentLine
                                   , nestedComments, identStart, identLetter
                                   , opStart, opLetter, reservedNames, reservedOpNames
                                   , caseSensitive
                                   , GenTokenParser
                                   , makeTokenParser )
import           Text.Parsec.String (parseFromFile)
import           Text.Parsec.Char (lower, upper, oneOf, alphaNum, letter)
import           Data.List.NonEmpty (NonEmpty ((:|)))
import           Control.Arrow (left)
import           Control.Monad (void)
import           Control.Monad.Identity (runIdentity)
    
import           TorXakis.Sort.FieldDefs (FieldDef (FieldDef), FieldDefs, fieldDefs, emptyFieldDefs)
import           TorXakis.Sort.Name (Name, fromNonEmpty, getName, toText)
import           TorXakis.Sort.ADTDefs ( ADTDef (ADTDef), Unchecked, U (U)
                                       , Sort (SortInt, SortBool)
                                       )
import           TorXakis.Sort.ConstructorDefs ( ConstructorDef (ConstructorDef)
                                               , ConstructorDefs, constructorDefs)

import           TorXakis.Compiler.Error (Error)
import           TorXakis.Parser.Data    (St (St), nextId, FieldDecl
                                         , Field (Field), ParseTree (ParseTree)
                                         , Metadata (Metadata)
                                         , SortRef (SortRef), OfSort, FuncDecl
                                         , ADTDecl )
import           TorXakis.Parser.Functions (fdeclP)
import           TorXakis.Parser.TypeDefs (adtP)
import           TorXakis.Parser.Common (TxsParser)

parse :: String -> Either Error ParsedDefs
parse = undefined

parseFile :: FilePath -> IO (Either Error ParsedDefs)
parseFile fp =  left (T.pack . show) <$> do
    input <- readFile fp
    -- Note that the initial state of eval state is never used.
    return $ runIdentity (runParserT txsP (St 1000) fp input)
    
-- | TorXakis definitions generated by the parser.
data ParsedDefs = ParsedDefs
    { adts  :: [ADTDecl]
    , fdefs :: [FuncDecl]
    } deriving (Eq, Show)

-- | TorXakis top-level definitions
data TLDef = TLADT ADTDecl
           | TLFun FuncDecl

-- | Group a list of top-level definitions per-type.
asParsedDefs :: [TLDef] -> ParsedDefs
asParsedDefs ts = ParsedDefs as fs
    where (as, fs) = foldr sep ([], []) ts
          sep  (TLADT a) (xs, ys) = (a:xs, ys)
          sep  (TLFun f) (xs, ys) = (xs, f:ys)

txsP :: TxsParser ParsedDefs
txsP = do
    ts <- many $  fmap TLADT adtP
              <|> fmap TLFun fdeclP
    eof
    return $ asParsedDefs ts
