{-# LANGUAGE OverloadedStrings #-}
module TorXakis.Parser where

import           Text.ParserCombinators.Parsec.Language (haskell)
import           Data.Text (Text)
import qualified Data.Text as T
import           Text.Parsec.String (Parser)
import           Text.Parsec.Token (identifier, lexeme)
import           Text.Parsec.String (parseFromFile)
import           Text.Parsec (parseTest, (<|>), many, (<?>), label)
import           Text.Parsec.Char (lower, oneOf, alphaNum, string)
import           Data.List.NonEmpty (NonEmpty ((:|)))

import           TorXakis.Sort.FieldDefs (FieldDef (FieldDef))
import           TorXakis.Sort.ADTDefs (Sort)
import           TorXakis.Sort.Name (Name, fromNonEmpty)

import           TorXakis.Compiler.Error (Error)

parse :: String -> Either Error ParsedDefs
parse = undefined

-- | TorXakis definitions generated by the parser.
data ParsedDefs = ParsedDefs
    { adts  :: [UADTDef]
    , fdefs :: [UFuncDef]
    } deriving (Eq, Show)

-- * TODO: take these types from the 'issue/565-newADTstructure' branch.

-- | Abstract data type definition. The parameter type represents the TorXakis
-- type of the ADT fields. For instance, the parser will return a
--
-- > ADTDef (Either Sort Text)
--
-- where if a field of an ADT has type Sort, it refers to a pare-existing type,
-- whereas if it has a type Text it refers to an ADT which does not exist yet
-- at the parsing stage.
--
data ADTDef sortRef = ADTDef
    deriving (Eq, Show)

type UType = Either Sort Name
type UADTDef = ADTDef UType

-- | Function definition.
data FuncDef sortRef = FuncDef
    deriving (Eq, Show)

type UFuncDef = FuncDef UType

-- ** Fields

fieldP :: Parser UFieldDef
fieldP =  do
    fn <- txsLexeme txsLowName
    _  <- txsLexeme (string "::")
    fs <- Right <$> txsLexeme txsLowName
    return $ FieldDef fn fs ""
--    UFieldDef <$>  <*> identifier haskell

txsLexeme :: Parser a -> Parser a
txsLexeme = lexeme haskell

txsLowName :: Parser Name
txsLowName = fromNonEmpty <$> txsLowNameNE

txsLowNameNE :: Parser (NonEmpty Char)
txsLowNameNE = (:|) <$> idStart <*> idEnd
    where
      idStart = lower <|> oneOf "_"
                `label`
                "Identifiers must start with a lowercase character or '_'"
      idEnd   = many $ alphaNum <|> oneOf "_"
                      `label`
                      "Identifiers must contain only alpha-numeric characters or '_'"
                       

type UFieldDef = FieldDef UType
