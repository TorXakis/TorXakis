{-# LANGUAGE TemplateHaskell #-}
module TorXakis.Parser
    ( ParsedDefs
    , adts
    , funcs
    , consts
    , txsP
    , parseFile
    , parse
    )
where

import qualified Data.Text as T
import           Text.Parsec ( (<|>), many, eof, runParserT )
import           Control.Arrow (left)
import           Control.Monad.Identity (runIdentity)
import           Lens.Micro (Lens', to, (^.), (%~))
import           Lens.Micro.TH (makeLenses)

import           TorXakis.Compiler.Error (Error)
import           TorXakis.Parser.Data
import           TorXakis.Parser.FuncDefs (fdeclP)
import           TorXakis.Parser.TypeDefs (adtP)
import           TorXakis.Parser.ConstDecl (constDeclsP)
import           TorXakis.Parser.Common (TxsParser)

-- | TorXakis definitions generated by the parser.
data ParsedDefs = ParsedDefs
    { _adts   :: [ADTDecl]
    , _funcs  :: [FuncDecl]
    , _consts :: [FuncDecl]
    } deriving (Eq, Show)
makeLenses ''ParsedDefs

parse :: String -> Either Error ParsedDefs
parse = undefined

parseFile :: FilePath -> IO (Either Error ParsedDefs)
parseFile fp =  left (T.pack . show) <$> do
    input <- readFile fp
    return $ runIdentity (runParserT txsP (mkState 1000) fp input)


-- | TorXakis top-level definitions
data TLDef = TLADT ADTDecl
           | TLFunc FuncDecl -- TODO: make this a list of '[FuncDecl]', and rename to 'TLFuncs'
           | TLConsts [FuncDecl]

-- | Group a list of top-level definitions per-type.
asParsedDefs :: [TLDef] -> ParsedDefs
asParsedDefs = foldr sep empty
    where
      sep (TLADT a) = adts %~ (a:)
      sep (TLFunc f) = funcs %~ (f:)
      sep (TLConsts cs) = consts %~ (cs++)      
      empty = ParsedDefs [] [] []

-- | Root parser for the TorXakis language.
txsP :: TxsParser ParsedDefs
txsP = do
    ts <- many $  fmap TLADT    adtP
              <|> fmap TLFunc   fdeclP
              <|> fmap TLConsts constDeclsP
    eof
    return $ asParsedDefs ts
