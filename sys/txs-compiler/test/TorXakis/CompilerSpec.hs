{-
TorXakis - Model Based Testing
Copyright (c) 2015-2017 TNO and Radboud University
See LICENSE at root directory of this repository.
-}
{-# LANGUAGE FlexibleContexts #-}
--------------------------------------------------------------------------------
-- |
-- Module      :  TorXakis.CompilerSpec
-- Copyright   :  (c) TNO and Radboud University
-- License     :  BSD3 (see the file license.txt)
--
-- Maintainer  :  damian.nadales@gmail.com (Embedded Systems Innovation by TNO)
-- Stability   :  experimental
-- Portability :  portable
--
-- Tests for the 'TorXakis' compiler.
--------------------------------------------------------------------------------
module TorXakis.CompilerSpec
    (spec)
where

import           Data.Either          (isRight)
import           Data.Foldable        (traverse_)
import qualified Data.Map             as Map
import           Data.Set             (Set)
import qualified Data.Set             as Set
import           GHC.Stack
import           System.FilePath      ((</>))
import           System.FilePath.Find (extension, find, (==?))
import           Test.Hspec           (Expectation, Spec, describe, it,
                                       parallel, runIO, shouldBe, shouldSatisfy)

import           FuncTable            (Signature, toMap)
import           Id                   (Id, Resettable, reset)
import           Sigs                 (Sigs, chan, func, pro, sort)
import           TxsAlex              (txsLexer)
import           TxsDefs              (CnectDef (CnectDef), TxsDefs, chanDefs,
                                       cnectDefs, cstrDefs, funcDefs, goalDefs,
                                       mapperDefs, modelDefs, procDefs,
                                       purpDefs, sortDefs, statDefs, varDefs)

import           TxsHappy             (txsParser)
import           VarId                (VarId)

import           TorXakis.Compiler    (compileFile)

spec :: Spec
spec = do
    describe "Correctly compiles the incremental (WIP)" $ do
        fs <- runIO $ find (return True) (extension ==? ".txs")
              ("test" </> "data" </> "success")
        parallel $ traverse_ compareWithCurrent fs
    describe "Compiles the examples in `examps` folder (WIP)" $ do
        fs <- runIO $ find (return True) (extension ==? ".txs")
              ("test" </> "data" </> "examps")
        parallel $ traverse_ testCompiler fs
    describe "Correctly compiles  the HUGE models" $ do
        fs <- runIO $ find (return True) (extension ==? ".txs")
                           ("test" </> "data" </> "parser" </> "huge")
        parallel $ traverse_ testCompiler fs
    where
        testCompiler fp = it (show fp) $ do
            r <- compileFile fp
            r `shouldSatisfy` isRight
        compareWithCurrent fp = it (show fp) $ do
            r <- compileFile fp
            -- First sanity check, the models are successfully compiled.
            r `shouldSatisfy` isRight
            let Right (_, tdefs, sigs) = r
            (_, tdefs', sigs') <- txsCompile fp
            -- Check that the 'TxsDef's generated by the `front` coincide with
            -- those generated by `txs-compiler`
            sortDefs    tdefs `shouldBeModUids` sortDefs    tdefs'
            cstrDefs    tdefs `shouldBeModUids` cstrDefs    tdefs'
            funcDefs    tdefs `shouldBeModUids` funcDefs    tdefs'
            procDefs    tdefs `shouldBeModUids` procDefs    tdefs'
            chanDefs    tdefs `shouldBeModUids` chanDefs    tdefs'
            varDefs     tdefs `shouldBeModUids` varDefs     tdefs'
            statDefs    tdefs `shouldBeModUids` statDefs    tdefs'
            modelDefs   tdefs `shouldBeModUids` modelDefs   tdefs'
            purpDefs    tdefs `shouldBeModUids` purpDefs    tdefs'
            goalDefs    tdefs `shouldBeModUids` goalDefs    tdefs'
            mapperDefs  tdefs `shouldBeModUids` mapperDefs  tdefs'

            -- The connect defs deserve a special treatment, since we don't
            -- care about the order of the @ConnDef@s in the @CnectDef@s.
            traverse_ (uncurry shouldBeModUids) $
                zip (Map.keys $ cnectDefs tdefs) (Map.keys $ cnectDefs tdefs')
            traverse_ (uncurry cnectDefShouldBe) $
                zip (Map.elems $ cnectDefs tdefs) (Map.elems $ cnectDefs tdefs')
            -- Check that the `Sigs` generated by `front` coincide with those
            -- generated by `txs-compiler`. We cannot test the handlers for
            -- equality, since they are functions.
            Set.fromList (chan sigs) `shouldBeModUids` Set.fromList (chan sigs')
            signatures sigs          `shouldBeModUids` signatures sigs'
            Set.fromList (pro sigs)  `shouldBeModUids` Set.fromList (pro sigs')
            sort       sigs          `shouldBeModUids` sort       sigs'
            (Map.keys . toMap . func) sigs `shouldBe` (Map.keys . toMap . func) sigs'
                where
                  signatures :: Sigs VarId -> Set Signature
                  signatures = Set.fromList . concat . (Map.keys <$>) . Map.elems . toMap . func

-- | Equality modulo unique id's.
shouldBeModUids :: (HasCallStack, Resettable e, Show e, Eq e) => e -> e -> Expectation
e0 `shouldBeModUids` e1 = reset e0 `shouldBe` reset e1


-- | Compare the @CnectDef@s regardless of the order of their @ConnDef@s.
cnectDefShouldBe :: CnectDef -> CnectDef -> Expectation
cnectDefShouldBe (CnectDef t0 xs) (CnectDef t1 ys) = do
    t0 `shouldBe` t1
    Set.fromList (reset xs) `shouldBe` Set.fromList (reset ys)


txsCompile :: FilePath -> IO (Id, TxsDefs, Sigs VarId)
txsCompile = (txsParser . txsLexer <$>) . readFile
