FUNCDEF const(x, y :: Int) :: Int ::=   
    x
ENDDEF

FUNCDEF twenty(x :: Int) :: Int ::=
    -- LET z = 10; b = True IN x NI
    20
ENDDEF

FUNCDEF let(x :: Int) :: Int ::=
    LET x = 10; y :: Bool = True IN x NI
ENDDEF

FUNCDEF let2(x :: Int; z :: Bool) :: Int ::=
    LET x = 10; y :: Bool = True; z = 9 IN z NI
ENDDEF

FUNCDEF let3(x :: Int; z :: Int) :: Int ::=
    LET x = 10; y :: Bool = True; z = 9 IN z NI
ENDDEF

FUNCDEF let4(x :: Bool; y :: Int; z :: Int) :: Int ::=
    LET a :: Int = y
    IN a
    NI
ENDDEF

FUNCDEF let5(x :: Bool; y :: Int; z :: Int) :: Int ::=
    LET a = y
    IN a
    NI
ENDDEF

FUNCDEF h() :: String ::=
    g
ENDDEF

FUNCDEF g() :: String ::=
    "Hello"
ENDDEF

FUNCDEF if(x :: Bool; y :: Int; z :: Int) :: Int ::=
    IF x THEN y ELSE z FI
ENDDEF

FUNCDEF if2(x :: Bool; y :: Int; z :: Int) :: Int ::=
    LET a :: Int = IF x THEN y ELSE z FI
    IN a
    NI
ENDDEF

FUNCDEF if3(x :: Bool; y :: Int; z :: Int) :: Int ::=
    LET a = IF x THEN y ELSE z FI
    IN a
    NI
ENDDEF

FUNCDEF if5(x :: Bool; y :: Int; z :: Int) :: Int ::=
    IF x THEN
        LET z = 10 IN z NI
    ELSE
        LET z = 20 IN z NI
    FI
ENDDEF

FUNCDEF if6(x :: Bool; y :: Int; z :: Int) :: Int ::=
    LET a = LET b = 10 IN b NI
    IN a
    NI
ENDDEF

FUNCDEF if7(x :: Bool; y :: Int; z :: Int) :: Int ::=
    LET a = IF x THEN
               LET z = 10 IN z NI
            ELSE
                LET z = 20 IN z NI
            FI
    IN a
    NI
ENDDEF

FUNCDEF if9(x :: Bool; y :: Int; z :: Int; w :: Bool) :: Int ::=
    IF x THEN
        LET a = IF x THEN
                   LET z = 10 IN z NI
                ELSE
                    IF LET g = 20 IN x NI THEN
                        LET z = 20 IN z NI
                    ELSE
                       33
                    FI
                FI
        IN a NI
    ELSE
        LET q = IF w THEN y ELSE LET b = 10 IN b NI FI
        IN q NI
    FI
ENDDEF

FUNCDEF plus(x :: Int; y :: Int) :: Int ::=
    x + y
ENDDEF

FUNCDEF plus2(x :: Int; y :: Int) :: Int ::=
    x + y + x
ENDDEF

FUNCDEF plus3(x :: Int; y :: Int) :: Int ::=
    x + plus(y, x)
ENDDEF

FUNCDEF plus4(x :: Int; y :: Int) :: Int ::=
    plus(y, x) + x
ENDDEF

FUNCDEF op(x :: Int; y :: Int) :: Int ::=
    x + y - x
ENDDEF

FUNCDEF concat(xs :: String; ys :: String) :: String ::=
    xs ++ ys
ENDDEF

FUNCDEF concat2(xs :: String; ys :: String) :: String ::=
     ys ++ concat (xs, ys)
ENDDEF

FUNCDEF composedOps(x :: Int; y :: Int; z :: Int) :: Int ::=
    x + x * y + z / x - 10 
ENDDEF

FUNCDEF composedOps2(x :: Int; y :: Int; z :: Int) :: Int ::=
    IF x == y
    THEN x + x * y + z / x - 10
    ELSE 203
    FI
ENDDEF

FUNCDEF composedOps3(x :: Int; y :: Int; z :: Int) :: Int ::=
    x + x * (y + (z + y))
ENDDEF

FUNCDEF composedOps4(x :: Int; y :: Int; z :: Int) :: Int ::=
    x + x * (y + (IF x < y THEN z + y ELSE x - y FI))
ENDDEF

FUNCDEF composedOps5(x :: Int; y :: Int; z :: Int) :: Int ::=
    x + x * (y + (
      IF x < y THEN
           LET q = IF z > 1 THEN 10 ELSE 0 FI; p = 20 IN z + y + p * q NI
      ELSE
          x - y
      FI
      ))
ENDDEF

FUNCDEF composedOps6(x :: Int; y :: Int; z :: Int) :: Int ::=
    IF LET r = x + x * (y + (
          IF x < y THEN
               LET q = IF z > 1 THEN 10 ELSE 0 FI; p = 20 IN z + y + p * q NI
          ELSE
              x - y
          FI
          ))
        IN r NI > 0
    THEN
        IF z < 1 THEN x ELSE y FI
    ELSE
        15
    FI
ENDDEF

TYPEDEF Pair ::= Pair { fst, snd :: Int } ENDDEF

-- | Because 'TriPair' is more fun that 'Tuple'.
TYPEDEF TriPair ::= TriPair { fst, snd, trd :: Int } ENDDEF

FUNCDEF composedOps4(p :: Pair) :: Int ::=
        fst(p) + snd(p)
ENDDEF

FUNCDEF composedOps5(p :: TriPair) :: Int ::=
        fst(p) + snd(p) + trd(p)
ENDDEF

FUNCDEF stringy() :: String ::=
        fromXml("Hello")
ENDDEF

-- TODO: add these test cases as well, depending on which kind of let
-- expressions we support.
--
-- FUNCDEF swap (a,b :: Int) :: Int ::=
--     LET a = b, b = a IN 2*a + b NI
-- ENDDEF
-- will return the value 2*b + a where a and b refer to the parameters
--
--
-- FUNCDEF swap (a,b :: Int) :: Int ::=
--     LET a = b; b = a IN 2*a + b NI
-- ENDDEF
-- will return the value 3* b where b refers to the second parameter

-- TODO: it seems TorXakis cannot handle this. Could the new compiler?
-- FUNCDEF j(g :: String) :: String ::=
--     g
-- ENDDEF

-- TODO: this will fail since the types of v and w will be inferred in
-- parallel. If the `;` separator is kept we need to correct this. If the `,`
-- will be used instead, then a type-not-inferred error is the right semantics
-- (the identifier `v` is not yet in scope when `w` is declared).
--
-- FUNCDEF let4(x :: Int) :: Int ::=
--     LET v = x; w = v IN
--         w
--     NI
-- ENDDEF

-- This results in an:
--
-- >>  error, called at .stack-work/dist/x86_64-linux-nopie/Cabal-2.0.1.0/build/TxsHappy.hs:2593:541 in front-0.2.1.0-IN8pwRKbkji3Hd0yYBRsG1:TxsHappy
--
-- in TorXakis.
-- FUNCDEF letParallel(x :: Int) :: Int ::=
--     LET v = x, w = v IN
--         w
--     NI
-- ENDDEF
-- 
-- FUNCDEF swap(x :: Int) :: Int ::=
--     LET a = b, b = a IN
--         a
--     NI
-- ENDDEF
